<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Modification Tool</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <!-- Gradient Title -->
        <div class="title-container">
            <span class="title-char large" style="color: #ff0000;">B</span>
            <span class="title-char small" style="color: #ff3333;">A</span>
            <span class="title-char small" style="color: #ff6666;">R</span>
            <span class="title-char small" style="color: #ff9999;">E</span>
            <span class="title-char large" style="color: #ffcc00;">I</span>
            <span class="title-char small" style="color: #ffff33;">R</span>
            <span class="title-char small" style="color: #ffff66;">O</span>
            <span class="title-char small" style="color: #ffff99;">N</span>
        </div>

        <!-- File Selection -->
        <div class="input-group">
            <label for="inputFile">1. Select Animation File:</label>
            <input type="file" id="inputFile" accept=".bytes,.txt">
        </div>

        <!-- File Information Display -->
        <div id="fileInfo" class="file-info" style="display: none;">
            <h3>üìÅ File Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <span class="info-label">Filename:</span>
                    <span class="info-value" id="infoFilename">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">File Size:</span>
                    <span class="info-value" id="infoSize">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Frames:</span>
                    <span class="info-value" id="infoFrames">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Bones:</span>
                    <span class="info-value" id="infoBones">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Bone IDs:</span>
                    <span class="info-value" id="infoBoneIds">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Data Size:</span>
                    <span class="info-value" id="infoDataSize">-</span>
                </div>
            </div>
        </div>

        <!-- Operation Selection -->
        <div class="controls-panel">
            <h2>2. Operation Selection</h2>
            <label for="operationSelect">Operation:</label>
            <select id="operationSelect">
                <option value="SHORTEN">SHORTEN: Shortens animation by a factor</option>
                <option value="LENGTHEN">LENGTHEN: Lengthens animation by a factor</option>
                <option value="EXTRACT_CSV">EXTRACT_CSV: Extracts animation data to CSV</option>
                <option value="SPLICER">SPLICER: Splices two animations</option>
                <option value="DASH">DASH: Applies dash effect</option>
                <option value="BIRTH_LOCATION">BIRTH_LOCATION: Birth location offset</option>
                <option value="X_DOUBLE">X_DOUBLE: Doubles X-axis values</option>
                <option value="TRIMMER">TRIMMER: Removes frame range</option>
                <option value="AXIS_ADDER">AXIS_ADDER: Adds values to axis</option>
                <option value="AXIS_SCALER">AXIS_SCALER: Scales bone coordinates</option>
            </select>

            <!-- Dynamic Parameters -->
            <div id="paramsContainer"></div>
        </div>

        <!-- Splicer Section -->
        <div id="splicerSection" class="special-panel" style="display: none;">
            <h3>SPLICER Parameters</h3>
            <div class="file-pair">
                <div class="file-input">
                    <label>File 1:</label>
                    <input type="file" id="splicerFile1" accept=".bytes,.txt">
                    <div class="splicer-frame-info" id="splicerFile1Info"></div>
                    <input type="text" id="splicerRange1" placeholder="1-10" value="1-10">
                </div>
                <div class="file-input">
                    <label>File 2:</label>
                    <input type="file" id="splicerFile2" accept=".bytes,.txt">
                    <div class="splicer-frame-info" id="splicerFile2Info"></div>
                    <input type="text" id="splicerRange2" placeholder="1-10" value="1-10">
                </div>
            </div>
            <p class="note">Files must have identical bone structures</p>
        </div>

        <!-- Bone Selection -->
        <div id="boneSelectionSection" class="special-panel" style="display: none;">
            <h3>Bone Selection</h3>
            <div class="bone-controls">
                <button id="selectAllBones" class="btn-secondary">Select All</button>
                <button id="deselectAllBones" class="btn-secondary">Deselect All</button>
            </div>
            <div id="boneList" class="bone-list"></div>
        </div>

        <!-- Action Buttons -->
        <div class="action-buttons">
            <button id="runButton" class="btn-primary" disabled>Run Operation</button>
            <button id="settingsButton" class="btn-secondary">Settings</button>
            <label class="checkbox-label">
                <input type="checkbox" id="saveCSV" checked>
                Save CSV Comparison
            </label>
        </div>

        <!-- Progress Bar -->
        <div class="progress-bar" style="display: none;" id="progressContainer">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <!-- Log Output -->
        <div class="log-area">
            <h2>Processing Log</h2>
            <pre id="outputLog">Select an animation file to begin...</pre>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h2>Settings</h2>
            <div class="setting-group">
                <label>Export Format:</label>
                <select id="exportExt">
                    <option value=".bytes">.bytes</option>
                    <option value=".txt">.txt</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button id="saveSettings" class="btn-primary">Save</button>
                <button id="cancelSettings" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { AnimationProcessor } from './animation-processor.js';
        
        // UI Controller
        class UIController {
            constructor() {
                this.processor = new AnimationProcessor(document.getElementById('outputLog'));
                this.currentFile = null;
                this.currentAnimationData = null;
                this.splicerFiles = { file1: null, file2: null };
                this.initEventListeners();
                this.updateParametersUI();
            }

            initEventListeners() {
                // File input
                document.getElementById('inputFile').addEventListener('change', (e) => {
                    this.handleFileSelect(e);
                });

                // Operation selection
                document.getElementById('operationSelect').addEventListener('change', () => {
                    this.updateParametersUI();
                });

                // Run button
                document.getElementById('runButton').addEventListener('click', () => {
                    this.runOperation();
                });

                // Settings
                document.getElementById('settingsButton').addEventListener('click', () => {
                    this.showSettings();
                });

                document.getElementById('saveSettings').addEventListener('click', () => {
                    this.saveSettings();
                });

                document.getElementById('cancelSettings').addEventListener('click', () => {
                    this.hideSettings();
                });

                // Bone selection
                document.getElementById('selectAllBones').addEventListener('click', () => {
                    this.toggleAllBones(true);
                });

                document.getElementById('deselectAllBones').addEventListener('click', () => {
                    this.toggleAllBones(false);
                });

                // Splicer file inputs
                document.getElementById('splicerFile1').addEventListener('change', (e) => {
                    this.handleSplicerFileSelect(e, 'file1');
                });

                document.getElementById('splicerFile2').addEventListener('change', (e) => {
                    this.handleSplicerFileSelect(e, 'file2');
                });
            }

            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.currentFile = file;
                    this.processor.log(`üìÅ File selected: ${file.name}`, 'info');
                    
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        this.currentAnimationData = this.processor.parseAnimationData(arrayBuffer, file.name);
                        
                        if (this.currentAnimationData) {
                            this.displayFileInfo(file, this.currentAnimationData);
                            document.getElementById('runButton').disabled = false;
                            this.updateBoneList();
                        } else {
                            document.getElementById('runButton').disabled = true;
                        }
                    } catch (error) {
                        this.processor.log(`‚úó Error reading file: ${error}`, 'error');
                        document.getElementById('runButton').disabled = true;
                    }
                }
            }

            async handleSplicerFileSelect(event, fileKey) {
                const file = event.target.files[0];
                if (file) {
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const animationData = this.processor.parseAnimationData(arrayBuffer, file.name);
                        
                        if (animationData) {
                            this.splicerFiles[fileKey] = { file, animationData };
                            const infoElement = document.getElementById(`splicerFile${fileKey.replace('file', '')}Info`);
                            infoElement.textContent = `${animationData.framesLength} frames, ${animationData.boneIdsLength} bones`;
                            
                            // Enable run button if both files are loaded
                            if (this.splicerFiles.file1 && this.splicerFiles.file2) {
                                document.getElementById('runButton').disabled = false;
                            }
                        }
                    } catch (error) {
                        this.processor.log(`‚úó Error reading splicer file ${fileKey}: ${error}`, 'error');
                    }
                }
            }

            displayFileInfo(file, animationData) {
                const fileInfo = document.getElementById('fileInfo');
                fileInfo.style.display = 'block';

                document.getElementById('infoFilename').textContent = file.name;
                document.getElementById('infoSize').textContent = this.processor.formatFileSize(file.size);
                document.getElementById('infoFrames').textContent = animationData.framesLength;
                document.getElementById('infoBones').textContent = animationData.boneIdsLength;
                document.getElementById('infoBoneIds').textContent = animationData.boneIds.join(', ');
                document.getElementById('infoDataSize').textContent = this.processor.formatFileSize(
                    animationData.totalSize - animationData.dataOffset
                );
            }

            updateParametersUI() {
                const operation = document.getElementById('operationSelect').value;
                const container = document.getElementById('paramsContainer');
                const splicerSection = document.getElementById('splicerSection');
                const boneSection = document.getElementById('boneSelectionSection');

                container.innerHTML = '';
                splicerSection.style.display = 'none';
                boneSection.style.display = 'none';

                switch (operation) {
                    case 'SHORTEN':
                    case 'LENGTHEN':
                        this.createParamRow(container, 'factor', 'Factor:', '2.0');
                        break;
                    case 'DASH':
                        this.createDashUI(container);
                        break;
                    case 'BIRTH_LOCATION':
                        this.createParamRow(container, 'total_offset', 'Total X Offset:', '200.0');
                        this.createDropdownRow(container, 'direction', 'Direction:', ['Towards', 'Away']);
                        break;
                    case 'SPLICER':
                        splicerSection.style.display = 'block';
                        document.getElementById('runButton').disabled = !(this.splicerFiles.file1 && this.splicerFiles.file2);
                        break;
                    case 'TRIMMER':
                        const frameCount = this.currentAnimationData ? this.currentAnimationData.framesLength : '?';
                        this.createParamRow(container, 'range', `Remove frames (1-${frameCount}):`, '1-10');
                        break;
                    case 'AXIS_ADDER':
                        this.createParamRow(container, 'x_offset', 'X Offset:', '0.0');
                        this.createParamRow(container, 'y_offset', 'Y Offset:', '0.0');
                        this.createParamRow(container, 'z_offset', 'Z Offset:', '0.0');
                        this.createParamRow(container, 'bone_id', 'Bone ID (-1 for all):', '-1');
                        break;
                    case 'AXIS_SCALER':
                        this.createParamRow(container, 'scale_factor', 'Scale Factor:', '1.5');
                        boneSection.style.display = 'block';
                        break;
                }
            }

            createDashUI(container) {
                // Dash type selection
                const typeRow = document.createElement('div');
                typeRow.className = 'param-row';
                typeRow.innerHTML = `
                    <label>Dash Type:</label>
                    <select id="param_dash_type">
                        <option value="Towards">Towards</option>
                        <option value="Away">Away</option>
                        <option value="Split Dash">Split Dash</option>
                    </select>
                `;
                container.appendChild(typeRow);

                // Dash parameters (will be updated based on type)
                this.dashParamsContainer = document.createElement('div');
                container.appendChild(this.dashParamsContainer);

                // Event listener for dash type changes
                document.getElementById('param_dash_type').addEventListener('change', () => {
                    this.updateDashParamsUI();
                });

                this.updateDashParamsUI();
            }

            updateDashParamsUI() {
                const dashType = document.getElementById('param_dash_type').value;
                this.dashParamsContainer.innerHTML = '';

                if (dashType === 'Split Dash') {
                    this.createParamRow(this.dashParamsContainer, 'order', 'First Dash:', 'Towards');
                    this.createParamRow(this.dashParamsContainer, 'phase1_frames', 'Phase 1 Frames:', '30');
                    this.createParamRow(this.dashParamsContainer, 'p1_offset', 'Phase 1 Offset:', '10.0');
                    this.createParamRow(this.dashParamsContainer, 'p2_offset', 'Phase 2 Offset:', '5.0');
                } else {
                    this.createParamRow(this.dashParamsContainer, 'offset_factor', 'Offset Factor:', '10.0');
                }
            }

            createParamRow(container, id, label, placeholder) {
                const row = document.createElement('div');
                row.className = 'param-row';
                
                const labelEl = document.createElement('label');
                labelEl.textContent = label;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `param_${id}`;
                input.placeholder = placeholder;
                input.value = placeholder;
                
                row.appendChild(labelEl);
                row.appendChild(input);
                container.appendChild(row);
            }

            createDropdownRow(container, id, label, options) {
                const row = document.createElement('div');
                row.className = 'param-row';
                
                const labelEl = document.createElement('label');
                labelEl.textContent = label;
                
                const select = document.createElement('select');
                select.id = `param_${id}`;
                options.forEach(option => {
                    const optionEl = document.createElement('option');
                    optionEl.value = option;
                    optionEl.textContent = option;
                    select.appendChild(optionEl);
                });
                
                row.appendChild(labelEl);
                row.appendChild(select);
                container.appendChild(row);
            }

            updateBoneList() {
                if (!this.currentAnimationData) return;

                const boneList = document.getElementById('boneList');
                boneList.innerHTML = '';
                
                this.currentAnimationData.boneIds.forEach(boneId => {
                    const boneItem = document.createElement('div');
                    boneItem.className = 'bone-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = boneId;
                    checkbox.checked = true;
                    checkbox.id = `bone_${boneId}`;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `bone_${boneId}`;
                    label.textContent = `${boneId}: ${this.processor.BONE_MAP[boneId] || 'Unknown'}`;
                    label.style.marginLeft = '8px';
                    
                    boneItem.appendChild(checkbox);
                    boneItem.appendChild(label);
                    boneList.appendChild(boneItem);
                });
            }

            toggleAllBones(select) {
                const checkboxes = document.querySelectorAll('#boneList input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = select;
                });
            }

            getSelectedBones() {
                const checkboxes = document.querySelectorAll('#boneList input[type="checkbox"]:checked');
                return Array.from(checkboxes).map(cb => parseInt(cb.value));
            }

            getOperationParams() {
                const operation = document.getElementById('operationSelect').value;
                const params = { operation };
                
                // Get dynamic parameters
                const paramInputs = document.querySelectorAll('#paramsContainer input, #paramsContainer select');
                paramInputs.forEach(input => {
                    const paramName = input.id.replace('param_', '');
                    params[paramName] = input.value;
                });

                // Get splicer parameters if applicable
                if (operation === 'SPLICER') {
                    params.range1 = document.getElementById('splicerRange1').value;
                    params.range2 = document.getElementById('splicerRange2').value;
                }

                return params;
            }

            getDecimationParams(floatFactor) {
                if (floatFactor < 1.0) {
                    this.processor.log('Warning: Factor must be 1.0 or greater. Using 1.0.', 'warning');
                    floatFactor = 1.0;
                }
                
                const inverseRatio = 1.0 / floatFactor;
                const numeratorInv = Math.round(inverseRatio * 10);
                const denominatorInv = 10;

                const commonInv = this.gcd(numeratorInv, denominatorInv);
                const factorD = numeratorInv / commonInv;
                const factorN = denominatorInv / commonInv;

                this.processor.log(`Decimation ratio: ${floatFactor} -> Keep ${factorD} frames out of every ${factorN}`, 'info');
                return { factorN, factorD };
            }

            gcd(a, b) {
                return b === 0 ? a : this.gcd(b, a % b);
            }

            async runOperation() {
                const operation = document.getElementById('operationSelect').value;
                
                if (operation === 'SPLICER') {
                    await this.runSplicerOperation();
                    return;
                }

                if (!this.currentFile || !this.currentAnimationData) {
                    this.processor.log('‚úó Error: Please select a valid animation file first.', 'error');
                    return;
                }

                this.processor.clearLog();
                this.processor.log('üöÄ Starting operation...', 'info');
                this.processor.updateProgress(5);

                try {
                    const params = this.getOperationParams();
                    const exportExt = document.getElementById('exportExt').value;
                    const saveCSV = document.getElementById('saveCSV').checked;

                    let result;
                    let outputTag;

                    switch (params.operation) {
                        case 'SHORTEN': {
                            const factor = parseFloat(params.factor);
                            const { factorN, factorD } = this.getDecimationParams(factor);
                            result = this.processor.shortenAnimation(this.currentAnimationData, factorN, factorD);
                            outputTag = `SHORTEN_x${factor.toFixed(1).replace('.', '_')}`;
                            break;
                        }
                        case 'LENGTHEN': {
                            const factor = parseInt(params.factor);
                            result = this.processor.lengthenAnimation(this.currentAnimationData, factor);
                            outputTag = `LENGTHEN_x${factor}`;
                            break;
                        }
                        case 'X_DOUBLE':
                            result = this.processor.xDoubleAnimation(this.currentAnimationData);
                            outputTag = 'X_DOUBLE';
                            break;
                        case 'DASH': {
                            const offsetFactor = parseFloat(params.offset_factor);
                            const directionSign = params.dash_type === 'Towards' ? 1 : -1;
                            result = this.processor.dashAnimation(this.currentAnimationData, offsetFactor, directionSign);
                            const directionChar = directionSign > 0 ? 'P' : 'N';
                            outputTag = `DASH_${directionChar}_x${offsetFactor.toFixed(1).replace('.', '_')}`;
                            break;
                        }
                        case 'BIRTH_LOCATION': {
                            const totalOffset = parseFloat(params.total_offset);
                            const directionSign = params.direction === 'Towards' ? 1 : -1;
                            result = this.processor.birthLocationAnimation(this.currentAnimationData, totalOffset, directionSign);
                            const directionChar = directionSign > 0 ? 'P' : 'N';
                            outputTag = `BIRTH_LOC_${directionChar}_x${totalOffset.toFixed(1).replace('.', '_')}`;
                            break;
                        }
                        case 'TRIMMER': {
                            const [start, end] = params.range.split('-').map(x => parseInt(x) - 1);
                            result = this.processor.trimmerAnimation(this.currentAnimationData, start, end);
                            outputTag = 'TRIMMER';
                            break;
                        }
                        case 'AXIS_ADDER': {
                            const xOffset = parseFloat(params.x_offset);
                            const yOffset = parseFloat(params.y_offset);
                            const zOffset = parseFloat(params.z_offset);
                            const boneId = parseInt(params.bone_id);
                            result = this.processor.axisAdderAnimation(this.currentAnimationData, xOffset, yOffset, zOffset, boneId);
                            outputTag = 'AXIS_ADDER';
                            break;
                        }
                        case 'AXIS_SCALER': {
                            const scaleFactor = parseFloat(params.scale_factor);
                            const targetBoneIds = this.getSelectedBones();
                            result = this.processor.axisScalerAnimation(this.currentAnimationData, scaleFactor, targetBoneIds);
                            const boneCountStr = targetBoneIds.length > 0 ? `${targetBoneIds.length}bones` : 'allbones';
                            outputTag = `AXIS_SCALER_x${scaleFactor.toFixed(1).replace('.', '_')}_${boneCountStr}`;
                            break;
                        }
                        case 'EXTRACT_CSV': {
                            const csvData = this.processor.extractCSV(this.currentAnimationData);
                            const csvContent = csvData.map(row => row.join(',')).join('\n');
                            const outputFilename = `${this.currentFile.name.replace(/\.[^/.]+$/, "")}_extracted.csv`;
                            this.processor.downloadFile(csvContent, outputFilename, 'text/csv');
                            this.processor.updateProgress(0);
                            return;
                        }
                        default:
                            this.processor.log(`‚úó Operation "${params.operation}" not implemented`, 'error');
                            this.processor.updateProgress(0);
                            return;
                    }

                    this.processor.updateProgress(95);

                    if (result) {
                        // Reconstruct binary file
                        const finalBinary = this.processor.reconstructBinary(
                            this.currentAnimationData, 
                            result.newFramesLength, 
                            result.data,
                            result.remainingData
                        );

                        // Download result
                        const outputFilename = `${this.currentFile.name.replace(/\.[^/.]+$/, "")}_${outputTag}${exportExt}`;
                        this.processor.downloadFile(finalBinary, outputFilename, 'application/octet-stream');

                        // Extract CSV if requested
                        if (saveCSV && params.operation !== 'EXTRACT_CSV') {
                            const csvData = this.processor.extractCSV({
                                ...this.currentAnimationData,
                                framesLength: result.newFramesLength,
                                animationDataBytes: result.data
                            });
                            const csvContent = csvData.map(row => row.join(',')).join('\n');
                            const csvFilename = `${this.currentFile.name.replace(/\.[^/.]+$/, "")}_${outputTag}.csv`;
                            this.processor.downloadFile(csvContent, csvFilename, 'text/csv');
                        }
                    }

                    this.processor.updateProgress(100);
                    this.processor.log('‚úÖ Operation completed successfully!', 'success');

                } catch (error) {
                    this.processor.log(`‚úó Operation failed: ${error}`, 'error');
                    this.processor.updateProgress(0);
                }
            }

            async runSplicerOperation() {
                if (!this.splicerFiles.file1 || !this.splicerFiles.file2) {
                    this.processor.log('‚úó Error: Please select both files for SPLICER operation', 'error');
                    return;
                }

                this.processor.clearLog();
                this.processor.log('üöÄ Starting SPLICER operation...', 'info');

                try {
                    const params = this.getOperationParams();
                    const exportExt = document.getElementById('exportExt').value;

                    const result = await this.processor.splicerAnimation(
                        this.splicerFiles.file1.animationData,
                        this.splicerFiles.file2.animationData,
                        params.range1,
                        params.range2
                    );

                    if (result) {
                        const finalBinary = this.processor.reconstructBinary(
                            result.metadata,
                            result.newFramesLength,
                            result.data,
                            result.remainingData
                        );

                        const outputFilename = `${this.splicerFiles.file1.file.name.replace(/\.[^/.]+$/, "")}_${result.tag}${exportExt}`;
                        this.processor.downloadFile(finalBinary, outputFilename, 'application/octet-stream');

                        this.processor.log('‚úÖ SPLICER operation completed successfully!', 'success');
                    }

                    this.processor.updateProgress(0);

                } catch (error) {
                    this.processor.log(`‚úó SPLICER operation failed: ${error}`, 'error');
                    this.processor.updateProgress(0);
                }
            }

            showSettings() {
                document.getElementById('settingsModal').style.display = 'block';
            }

            hideSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }

            saveSettings() {
                const exportExt = document.getElementById('exportExt').value;
                localStorage.setItem('animationTool_exportExt', exportExt);
                this.hideSettings();
                this.processor.log('‚úì Settings saved', 'success');
            }

            loadSettings() {
                const savedExportExt = localStorage.getItem('animationTool_exportExt');
                if (savedExportExt) {
                    document.getElementById('exportExt').value = savedExportExt;
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            const uiController = new UIController();
            uiController.loadSettings();
        });
    </script>
</body>
</html>
